#!/usr/bin/env python

from enum import Enum

PACKAGE='lidar_slam'

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

#########################################################
#        Real-time LiDAR SLAM default parameters        #
#             (see Slam.h for description)              #
#########################################################

# Level of parameters
class Levels(Enum):
    GLOBAL = 0,
    LOGGING = 1,

# Structure parameters
#       Name                    Type  0
#       Description
#       Default                 Min       Max

# -------------------------------------------------------------------------------------------------
# General parameters
gen.add("n_threads", int_t, 0,
        "Max number of threads to use for parallel processing",
        4, 1, 32)
gen.add("twoD_mode", bool_t, 0,
        "Optimize only 2D pose (X, Y, rZ) of tracking_frame relatively to odometry_frame.",
        False)

# How to estimate Ego-Motion (approximate relative motion since last frame).
# The ego-motion step aims to give a fast and approximate initialization of new
# frame world pose to ensure faster and more precise convergence in Localization step.
#  0) No ego-motion step is performed : relative motion is Identity, new estimated
#     Tworld is equal to previous Tworld. Fast, but may lead to unstable and imprecise
#     Localization step if motion is important.
#  1) Previous motion is linearly extrapolated to estimate new Tworld pose from the
#     2 previous poses. Fast and precise if motion is roughly constant and continuous
#  2) Estimate Trelative (and therefore Tworld) by globally registering new frame
#     on previous frame. Slower and need textured enough environment, but do not
#     rely on constant motion hypothesis.
#  3) Previous motion is linearly extrapolated to estimate new Tworld pose from
#     the 2 previous poses. Then this estimation is refined by globally registering
#     new frame on previous frame. Slower and need textured enough environment,
#     but should be more precise and rely less on constant motion hypothesis.
gen.add("ego_motion", int_t, 0,
        "Ego-Motion estimation mode (see cfg for details)",
        1, 0, 3)

  # Undistortion mode, to correct rolling shutter distortion during frame acquisition.
  # The undistortion should greatly improve the accuracy for smooth motions,
  # but might be unstable for high-frequency motions.
  #  0) NONE: no undistortion is performed :
  #     - End scan pose is optimized using rigid registration of raw scan and map.
  #     - Raw input scan is added to map.
  #  1) ONCE: undistortion is performed only one using estimated ego-motion:
  #     - Begin and end scan poses are linearly interpolated using estimated ego-motion.
  #     - Scan is linearly undistorted between begin and end scan poses.
  #     - Scan pose is iteratively optimized using rigid registration of undistorted scan and map.
  #     - Undistorted scan is added to map.
  #  2) REFINED: undistortion is iteratively refined using optimized ego-motion:
  #     - Begin and end scan poses are linearly interpolated using ego-motion.
  #     - Scan is linearly undistorted between begin and end scan poses.
  #     - Scan pose is optimized using rigid registration of undistorted scan and map.
  #     - Iterate the three previous steps with updated ego-motion and poses.
  #     - Undistorted scan is added to map.
gen.add("undistortion", int_t, 0,
        "Undistortion mode, to correct rolling shutter distortion during frame acquisition",
        2, 0, 2)

gen.add("verbosity", int_t, 0,
        "Verbosity level",
        3, 0, 5)

# -------------------------------------------------------------------------------------------------
logging_group = gen.add_group("Logging", type="collapse")
# Optional logging of computed pose, localization covariance and keypoints of each processed frame.
#  - A value of 0. will disable logging.
#  - A negative value will log all incoming data, without any timeout.
#  - A positive value will keep only most recent data, forgetting all previous data older than timeout seconds.
# Logged data will be used for pose graph optimization, GPS antenna/LiDAR sensor calibration using GPS data
# and velocity/acceleration estimations.
logging_group.add("log__timeout", double_t, 1,
                  "Logging timeout",
                  0, 0, 1000)
# How to store pointclouds data during keypoints logging (if logging_timeout != 0):
#  0) PCL pointcloud                    (in RAM,     no compression,      no overhead)
#  1) Octree compressed binary data     (in RAM,    ~5x compression,   ~3 ms overhead)
#  2) Ascii format PCD file             (on disk, ~0.6x compression,   ~5 ms overhead)
#  3) Binary format PCD file            (on disk, ~1.3x compression, ~0.3 ms overhead)
#  4) Binary compressed format PCD file (on disk, ~1.5x compression, ~0.8 ms overhead)
logging_group.add("log__storage_type", int_t, 1,
                  "Storage mode for pointclouds data",
                  0, 0, 4)
# Decide whether to log all frames or only keyframes
# /!\ All log frames are used in post graph processing
logging_group.add("log__only_keyframes", bool_t, 1,
                  "Decide whether to log all frames or only keyframes",
                  False)

# -------------------------------------------------------------------------------------------------
# ICP and LM parameters for Ego-Motion registration step (used only if ego_motion is 2 or 3)
EM_group = gen.add_group("Ego Motion registration", type="collapse")
# Match
EM_group.add("em__max_neighbors_distance", double_t, 2,
             "[m] Max distance allowed between a current keypoint and its neighbors.",
             5., 4., 10.)
# Point to edge match
EM_group.add("em__edge_nb_neighbors", int_t, 2,
             "[>=2] Initial number of edge neighbors to extract, that will be filtered out to keep best candidates.",
             8, 2, 10)
EM_group.add("em__edge_min_nb_neighbors", int_t, 2,
             "[>=2] Min number of resulting filtered edge neighbors (max 1 per scan line) to approximate the corresponding line model.",
             3, 2, 10)
EM_group.add("em__edge_max_model_error", double_t, 2,
             "[m] Max RMSE allowed between neighborhood and its fitted line model to create a point to line constraint.",
             0.2, 0.1, 1.0)
# Point to plane match
EM_group.add("em__plane_nb_neighbors", int_t, 2,
             "[>=3] Number of plane neighbors to extract to approximate the corresponding plane model.",
             5, 2, 9)
# Contained in [0, 1]. OK if l1/l2 > planarity_threshold (with l2>l1>l0)
EM_group.add("em__planarity_threshold", double_t, 2,
             "Min ratio between the 2 highest eigen values of the plane neighborhood to create a point to plane constraint.",
             0.04, 0.00, 0.10)
EM_group.add("em__plane_max_model_error", double_t, 2,
             "[m] Max RMSE allowed between neighborhood and its fitted plane model to create a point to plane constraint.",
             0.1, 0.01, 0.2)
# Optimization
EM_group.add("em__ICP_max_iter", int_t, 2,
             "Number of ICP-optim iterations (building ICP matches then optimizing them) to perform.",
             4, 1, 30)
EM_group.add("em__LM_max_iter", int_t, 2,
             "Max number of iterations of the Levenberg-Marquardt optimizer to solve the ICP problem.",
             15, 1, 30)
EM_group.add("em__init_saturation_distance", double_t, 2,
             "[m] Initial distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
             5., 1., 8)
EM_group.add("em__final_saturation_distance", double_t, 2,
             "[m] Final distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
             1., 0.5, 2.)


# -------------------------------------------------------------------------------------------------
localization_group = gen.add_group("Localization", type="collapse")
localization_group.add("loc__max_neighbors_distance", double_t, 3,
                       "[m] Max distance allowed between a current keypoint and its neighbors.",
                       5., 10., 1.)
# Point to edge match
localization_group.add("loc__edge_nb_neighbors", int_t, 3,
                       "[>=2] Initial number of edge neighbors to extract, that will be filtered out to keep best candidates.",
                       9, 2, 18)
localization_group.add("loc__edge_min_nb_neighbors", int_t, 3,
                       "[>=2] Min number of resulting filtered edge neighbors (close to best line candidate) to approximate the corresponding line model.",
                       5, 2, 8)
localization_group.add("loc__edge_max_model_error", double_t, 3,
                       "[m] Max RMSE allowed between neighborhood and its fitted line model to create a point to line constraint.",
                       0.2, 0.1, 1.0)
# Point to plane match
localization_group.add("loc__plane_nb_neighbors", int_t, 3,
                       "[>=3] Number of plane neighbors to extract to approximate the corresponding plane model.",
                       7, 3, 18)
# Min ratio between the 2 highest eigen values of the plane neighborhood to create a point to plane constraint :
# Contained in [0, 1]. OK if l1/l2 > planarity_threshold (with l2>l1>l0)
localization_group.add("loc__planarity_threshold", double_t, 3,
                       "Min ratio between the 2 highest eigen values of the plane neighborhood to create a point to plane constraint",
                       0.04, 0.01, 0.1)
localization_group.add("loc__plane_max_model_error", double_t, 3,
                       "[m] Max RMSE allowed between neighborhood and its fitted plane model to create a point to plane constraint..",
                       0.1, 0.05, 0.2)
# Point to blob match
localization_group.add("loc__blob_nb_neighbors", int_t, 10,
                       "[>=4] Number of blob neighbors to extract to approximate the corresponding ellipsoid model.",
                       10, 4, 18)
# Optimization
localization_group.add("loc__ICP_max_iter", int_t, 3,
                       "Number of ICP-optim iterations (building ICP matches then optimizing them) to perform.",
                       3, 1, 30)
localization_group.add("loc__LM_max_iter", int_t, 3,
                       "Max number of iterations of the Levenberg-Marquardt optimizer to solve the ICP problem",
                       15, 1, 30)
localization_group.add("loc__init_saturation_distance", double_t, 3,
                       "[m] Initial distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
                       2., 0., 10.)
localization_group.add("loc__final_saturation_distance", double_t, 3,
                       "[m] Final distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
                       0.5, 0.1, 10.)

# -------------------------------------------------------------------------------------------------
# Keyframes parameters. Only keyframes points are added to the maps.
keyframes_group = gen.add_group("Keyframes", type="collapse")
keyframes_group.add("keyf__distance_threshold", double_t, 4,
                    "[m] Min distance to travel since last KF to add a new one",
                    0.5, 0.1, 2.)
keyframes_group.add("keyf__angle_threshold", double_t, 4,
                    "[°] Min angle to rotate since last KF to add a new one",
                    5., 0., 180.)
# WARNING : these parameters are linked to the confidence threshold parameter
  # If they are reduced, the confidence threshold may need to be increased to not take too many moving objects                    

# -------------------------------------------------------------------------------------------------
# Confidence estimators on pose output
confidence_group = gen.add_group("Confidence", type="collapse",)
overlap_group = confidence_group.add_group("Overlap", type="tab")
# 1 uses all points, 0.5 uses 1 point over 2, etc., 0 disables overlap computation.
overlap_group.add("overl__sampling_ratio", double_t, 5,
                  "# [0-1] Ratio of points to compute overlap on to save some time.",
                  0.5, 0., 1.)
motion_limits_group = confidence_group.add_group("Motion Limits", type="tab",)
motion_limits_group.add("ml__acceleration_min", double_t, 5,
                        "# [linear_acc (m/s2), angular_acc (°/s2)] Acceleration minimum.",
                        -16331239353195370)
motion_limits_group.add("ml__acceleration_max", double_t, 5,
                        "# [linear_acc (m/s2), angular_acc (°/s2)] Acceleration maximum.",
                        16331239353195370)
motion_limits_group.add("ml__velocity_min", double_t, 5,
                        "# [linear_vel (m/s2), angular_vel (°/s2)] Velocity minimum.",
                        -16331239353195370)
motion_limits_group.add("ml__velocity_max", double_t, 5,
                        "# [linear_vel (m/s2), angular_vel (°/s2)] Velocity maximum.",
                        16331239353195370)
# 0 disables motion limits check.
# WARNING : the logging time out must be set greater than this value.
motion_limits_group.add("ml__time_window_duration", double_t, 5,
                         "[s] Duration on which to compute the local velocity/acceleration.",
                         0., 0.)

# -------------------------------------------------------------------------------------------------
# Keypoints maps, saved as downsampled voxel grids
voxel_grid_group = gen.add_group("Voxel Grid", type="collapse")
    # How to update the maps:
    #  0) No update is performed. Initial maps are kept as they are.
    #     WARNING: Do not set this parameter to 0 if no initial maps have been loaded!
    #  1) New keypoints are added if they lie in a free voxel relatively to an initial map
    #  2) All new keypoints are added and the map is updated (initial keypoints can disappear)
    #     1) and 2) will be equivalent if no initial maps have been loaded.
    # This is equivalent to publishing :
    #          *SlamCommand::DISABLE_SLAM_MAP_UPDATE
    #          *SlamCommand::ENABLE_SLAM_MAP_EXPANSION
    #          *SlamCommand::ENABLE_SLAM_MAP_UPDATE
    # to 'slam_command' topic at startup.
voxel_grid_group.add("vg__update_maps", int_t, 6,
                      "Mode to update the maps",
                      2, 0, 2)

leaf_size_group = voxel_grid_group.add_group("Leaf Size")
leaf_size_group.add("ls__edges", double_t, 6,
                    "[m] Resolution used to downsample the edges map with a VoxelGrid filter.",
                    0.30, 0., 2.)
leaf_size_group.add("ls__intensity_edges", double_t, 6,
                    "[m] Resolution used to downsample the intensity edges map with a VoxelGrid filter.",
                    0.20, 0., 2.)
leaf_size_group.add("ls__planes", double_t, 6,
                    "[m] Resolution used to downsample the planes map with a VoxelGrid filter.",
                    0.60, 0., 2.)
leaf_size_group.add("ls__blobs", double_t, 6,
                    "[m] Resolution used to downsample the blobs map with a VoxelGrid filter.",
                    0.30, 0., 2.)
# WARNING: the leaf sizes are linked with the confidence threshold parameter
# if they are reduced the confidence threshold may need to by reduced as well to extract enough target keypoints


#* LOOK "HERE" in slam_config_outdoor to know which parameter continue
#TODO add precision than their is more info in .cfg than in rqt interface
#TODO if description is too long
#TODO define infinity macro
exit(gen.generate(PACKAGE, "lidar_slam", "LidarSlam"))