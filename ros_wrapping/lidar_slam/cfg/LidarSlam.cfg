#!/usr/bin/env python

from enum import Enum

PACKAGE='lidar_slam'

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()


#* Test constant
gen.const("int_const", int_t, 5, "An int constant.")


# Structure parameters
#       Name                    Type      Level
#       Description
#       Default                 Min       Max

#########################################################
#        Real-time LiDAR SLAM default parameters        #
#########################################################

# -------------------------------------------------------------------------------------------------
# General Parameters
general_group = gen.add_group("General parameters", type="collapse")

# SLAM will compute the pose of tracking_frame in odometry_frame coordinates system, using measurements in input pointcloud frames.
general_group.add("odometry_frame", str_t, 0,
                  "Frame in which SLAM odometry and maps are expressed (default: odom)",
                  "odom")
general_group.add("tracking_frame", str_t, 0,
                  "Frame to track (ensure a valid TF tree is published to link input pointcloud frame_id) (default: base_link)",
                  "base_link")

# Input LiDAR frames topics, expected as sensor_msgs/PointCloud2 messages with the following fields:
# - x, y, z (float): point coordinates
# - time (double): time offset to add to the pointcloud header timestamp to get approximate point-wise acquisition timestamp
# - intensity (float): intensity/reflectivity of the point
# - laser_id (uint16): numeric identifier of the laser ring that shot this point. The lowest/bottom laser ring should be 0, and it should increase upward.
# - device_id (uint8): numeric identifier of the LiDAR device/sensor. This id should be the same for all points of the cloud acquired by the same sensor.
# - label (uint8): optional input, not yet used.
general_group.add("input", str_t, 0,
                  "Array of input LiDAR frames topics [lidar_points1, lidar_points2, ...] (more info in LidarSlam.cfg)",
                  "[lidar_points]")

# -------------------------------------------------------------------------------------------------
output_group = gen.add_group("Output", type="collapse")

output_group.add("out__registered_points", bool_t, 0,
                 "Publish registered (and undistorted) SLAM pointcloud as LidarPoint PointCloud2 msg to topic 'slam_registered_points'.",
                 True)

out_pose_group = output_group.add_group("Output pose", type="tab")
out_pose_group.add("po__odom", bool_t, 0,
                   "Publish SLAM pose as an Odometry msg on 'slam_odom' topic.",
                   True)
out_pose_group.add("po__tf", bool_t, 0,
                   "Publish SLAM pose as a TF from 'odometry_frame' to 'tracking_frame'.",
                   True)
out_pose_group.add("po__predicted_odom", bool_t, 0,
                   "Publish latency-corrected SLAM pose as an Odometry msg on 'slam_predicted_odom' topic (default: false).",
                   False)
out_pose_group.add("po__predicted_tf", bool_t, 0,
                   "Publish latency-corrected SLAM pose as a TF from 'odometry_frame' to '<tracking_frame>_prediction' (default: false)",
                   False)

out_maps_group = output_group.add_group("Output maps", type="tab")
out_maps_group.add("ma__edges", bool_t, 0,
                "Publish edges keypoints map as a LidarPoint PointCloud2 msg to topic 'maps/edges'.",
                True)
out_maps_group.add("ma__intensity_edges", bool_t, 0,
                "Publish intensity edges keypoints map as a LidarPoint PointCloud2 msg to topic 'maps/intensity_edges'.",
                True)
out_maps_group.add("ma__planes", bool_t, 0,
                "Publish planes keypoints map as a LidarPoint PointCloud2 msg to topic 'maps/planes'.",
                True)
out_maps_group.add("ma__blobs", bool_t, 0,
                "Publish blobs keypoints map as a LidarPoint PointCloud2 msg to topic 'maps/blobs'.",
                True)

# WARNING : The submaps only exist if update_maps is not 0 (the map is not fixed)
out_submaps_group = output_group.add_group("Output submaps", type="tab")
out_submaps_group.add("sbm__edges", bool_t, 0,
                "Publish edges keypoints submap as a LidarPoint PointCloud2 msg to topic 'submaps/edges'.",
                True)
out_submaps_group.add("sbm__intensity_edges", bool_t, 0,
                "Publish intensity edges keypoints submap as a LidarPoint PointCloud2 msg to topic 'submaps/intensity_edges'.",
                True)
out_submaps_group.add("sbm__planes", bool_t, 0,
                "Publish planes keypoints submap as a LidarPoint PointCloud2 msg to topic 'submaps/planes'.",
                True)
out_submaps_group.add("sbm__blobs", bool_t, 0,
                "Publish blobs keypoints submap as a LidarPoint PointCloud2 msg to topic 'submaps/blobs'.",
                True)

out_keypoints_group = output_group.add_group("Output keypoints", type="tab")
out_keypoints_group.add("kp__edges", bool_t, 0,
                        "Publish extracted edges keypoints from current frame as a PointCloud2 msg to topic 'keypoints/edges'.",
                        True)
out_keypoints_group.add("kp__intensity_edges", bool_t, 0,
                        "Publish extracted intensity_edges keypoints from current frame as a PointCloud2 msg to topic 'keypoints/intensity_edges'.",
                        True)
out_keypoints_group.add("kp__planes", bool_t, 0,
                        "Publish extracted planes keypoints from current frame as a PointCloud2 msg to topic 'keypoints/planes'.",
                        True)
out_keypoints_group.add("kp__blobs", bool_t, 0,
                        "Publish extracted blobs keypoints from current frame as a PointCloud2 msg to topic 'keypoints/blobs'.",
                        True)


# -------------------------------------------------------------------------------------------------
# SLAM parameters (see Slam.h for description). Comment parameter to get default value.
slam_group = gen.add_group("SLAM parameters", type="collapse")

# General parameters
slam_general = slam_group.add_group("SLAM general parameters", type="collapse")
slam_general.add("n_threads", int_t, 0,
        "Max number of threads to use for parallel processing",
        4, 1, 32)
slam_general.add("twoD_mode", bool_t, 0,
        "Optimize only 2D pose (X, Y, rZ) of tracking_frame relatively to odometry_frame.",
        False)

# How to estimate Ego-Motion (approximate relative motion since last frame).
# The ego-motion step aims to give a fast and approximate initialization of new
# frame world pose to ensure faster and more precise convergence in Localization step.
#  0) No ego-motion step is performed : relative motion is Identity, new estimated
#     Tworld is equal to previous Tworld. Fast, but may lead to unstable and imprecise
#     Localization step if motion is important.
#  1) Previous motion is linearly extrapolated to estimate new Tworld pose from the
#     2 previous poses. Fast and precise if motion is roughly constant and continuous
#  2) Estimate Trelative (and therefore Tworld) by globally registering new frame
#     on previous frame. Slower and need textured enough environment, but do not
#     rely on constant motion hypothesis.
#  3) Previous motion is linearly extrapolated to estimate new Tworld pose from
#     the 2 previous poses. Then this estimation is refined by globally registering
#     new frame on previous frame. Slower and need textured enough environment,
#     but should be more precise and rely less on constant motion hypothesis.
slam_general.add("ego_motion", int_t, 0,
        "Ego-Motion estimation mode (more info in LidarSlam.cfg)",
        1, 0, 3)

  # Undistortion mode, to correct rolling shutter distortion during frame acquisition.
  # The undistortion should greatly improve the accuracy for smooth motions,
  # but might be unstable for high-frequency motions.
  #  0) NONE: no undistortion is performed :
  #     - End scan pose is optimized using rigid registration of raw scan and map.
  #     - Raw input scan is added to map.
  #  1) ONCE: undistortion is performed only one using estimated ego-motion:
  #     - Begin and end scan poses are linearly interpolated using estimated ego-motion.
  #     - Scan is linearly undistorted between begin and end scan poses.
  #     - Scan pose is iteratively optimized using rigid registration of undistorted scan and map.
  #     - Undistorted scan is added to map.
  #  2) REFINED: undistortion is iteratively refined using optimized ego-motion:
  #     - Begin and end scan poses are linearly interpolated using ego-motion.
  #     - Scan is linearly undistorted between begin and end scan poses.
  #     - Scan pose is optimized using rigid registration of undistorted scan and map.
  #     - Iterate the three previous steps with updated ego-motion and poses.
  #     - Undistorted scan is added to map.
slam_general.add("undistortion", int_t, 0,
        "Undistortion mode, to correct rolling shutter distortion during frame acquisition (more info in LidarSlam.cfg)",
        2, 0, 2)

slam_general.add("verbosity", int_t, 0,
        "Verbosity level",
        3, 0, 5)

# -------------------------------------------------------------------------------------------------
logging_group = slam_group.add_group("Logging", type="collapse")
# Optional logging of computed pose, localization covariance and keypoints of each processed frame.
#  - A value of 0. will disable logging.
#  - A negative value will log all incoming data, without any timeout.
#  - A positive value will keep only most recent data, forgetting all previous data older than timeout seconds.
# Logged data will be used for pose graph optimization, GPS antenna/LiDAR sensor calibration using GPS data
# and velocity/acceleration estimations.
logging_group.add("log__timeout", double_t, 1,
                  "Logging timeout (more info in LidarSlam.cfg)",
                  0, 0, 1000)
# How to store pointclouds data during keypoints logging (if logging_timeout != 0):
#  0) PCL pointcloud                    (in RAM,     no compression,      no overhead)
#  1) Octree compressed binary data     (in RAM,    ~5x compression,   ~3 ms overhead)
#  2) Ascii format PCD file             (on disk, ~0.6x compression,   ~5 ms overhead)
#  3) Binary format PCD file            (on disk, ~1.3x compression, ~0.3 ms overhead)
#  4) Binary compressed format PCD file (on disk, ~1.5x compression, ~0.8 ms overhead)
logging_group.add("log__storage_type", int_t, 1,
                  "Storage mode for pointclouds data (more info in LidarSlam.cfg)",
                  0, 0, 4)
# Decide whether to log all frames or only keyframes
# /!\ All log frames are used in post graph processing
logging_group.add("log__only_keyframes", bool_t, 1,
                  "Decide whether to log all frames or only keyframes",
                  False)

# -------------------------------------------------------------------------------------------------
# ICP and LM parameters for Ego-Motion registration step (used only if ego_motion is 2 or 3)
EM_group = slam_group.add_group("Ego Motion registration", type="collapse")
# Match
EM_group.add("em__max_neighbors_distance", double_t, 2,
             "[m] Max distance allowed between a current keypoint and its neighbors.",
             5., 4., 10.)
# Point to edge match
EM_group.add("em__edge_nb_neighbors", int_t, 2,
             "[>=2] Initial number of edge neighbors to extract, that will be filtered out to keep best candidates.",
             8, 2, 10)
EM_group.add("em__edge_min_nb_neighbors", int_t, 2,
             "[>=2] Min number of resulting filtered edge neighbors (max 1 per scan line) to approximate the corresponding line model.",
             3, 2, 10)
EM_group.add("em__edge_max_model_error", double_t, 2,
             "[m] Max RMSE allowed between neighborhood and its fitted line model to create a point to line constraint.",
             0.2, 0.1, 1.0)
# Point to plane match
EM_group.add("em__plane_nb_neighbors", int_t, 2,
             "[>=3] Number of plane neighbors to extract to approximate the corresponding plane model.",
             5, 2, 9)
# Contained in [0, 1]. OK if l1/l2 > planarity_threshold (with l2>l1>l0)
EM_group.add("em__planarity_threshold", double_t, 2,
             "Min ratio between the 2 highest eigen values of the plane neighborhood to create a point to plane constraint.",
             0.04, 0.00, 0.10)
EM_group.add("em__plane_max_model_error", double_t, 2,
             "[m] Max RMSE allowed between neighborhood and its fitted plane model to create a point to plane constraint.",
             0.1, 0.01, 0.2)
# Optimization
EM_group.add("em__ICP_max_iter", int_t, 2,
             "Number of ICP-optim iterations (building ICP matches then optimizing them) to perform.",
             4, 1, 30)
EM_group.add("em__LM_max_iter", int_t, 2,
             "Max number of iterations of the Levenberg-Marquardt optimizer to solve the ICP problem.",
             15, 1, 30)
EM_group.add("em__init_saturation_distance", double_t, 2,
             "[m] Initial distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
             5., 1., 8)
EM_group.add("em__final_saturation_distance", double_t, 2,
             "[m] Final distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
             1., 0.5, 2.)


# -------------------------------------------------------------------------------------------------
localization_group = slam_group.add_group("Localization", type="collapse")
localization_group.add("loc__max_neighbors_distance", double_t, 3,
                       "[m] Max distance allowed between a current keypoint and its neighbors.",
                       5., 10., 1.)
# Point to edge match
localization_group.add("loc__edge_nb_neighbors", int_t, 3,
                       "[>=2] Initial number of edge neighbors to extract, that will be filtered out to keep best candidates.",
                       9, 2, 18)
localization_group.add("loc__edge_min_nb_neighbors", int_t, 3,
                       "[>=2] Min number of resulting filtered edge neighbors (close to best line candidate) to approximate the corresponding line model.",
                       5, 2, 8)
localization_group.add("loc__edge_max_model_error", double_t, 3,
                       "[m] Max RMSE allowed between neighborhood and its fitted line model to create a point to line constraint.",
                       0.2, 0.1, 1.0)
# Point to plane match
localization_group.add("loc__plane_nb_neighbors", int_t, 3,
                       "[>=3] Number of plane neighbors to extract to approximate the corresponding plane model.",
                       7, 3, 18)
# Min ratio between the 2 highest eigen values of the plane neighborhood to create a point to plane constraint :
# Contained in [0, 1]. OK if l1/l2 > planarity_threshold (with l2>l1>l0)
localization_group.add("loc__planarity_threshold", double_t, 3,
                       "Min ratio between the 2 highest eigen values of the plane neighborhood to create a point to plane constraint",
                       0.04, 0.01, 0.1)
localization_group.add("loc__plane_max_model_error", double_t, 3,
                       "[m] Max RMSE allowed between neighborhood and its fitted plane model to create a point to plane constraint..",
                       0.1, 0.05, 0.2)
# Point to blob match
localization_group.add("loc__blob_nb_neighbors", int_t, 10,
                       "[>=4] Number of blob neighbors to extract to approximate the corresponding ellipsoid model.",
                       10, 4, 18)
# Optimization
localization_group.add("loc__ICP_max_iter", int_t, 3,
                       "Number of ICP-optim iterations (building ICP matches then optimizing them) to perform.",
                       3, 1, 30)
localization_group.add("loc__LM_max_iter", int_t, 3,
                       "Max number of iterations of the Levenberg-Marquardt optimizer to solve the ICP problem",
                       15, 1, 30)
localization_group.add("loc__init_saturation_distance", double_t, 3,
                       "[m] Initial distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
                       2., 0., 10.)
localization_group.add("loc__final_saturation_distance", double_t, 3,
                       "[m] Final distance beyond which residuals are saturated using Tukey loss to limit outlier contribution.",
                       0.5, 0.1, 10.)

# -------------------------------------------------------------------------------------------------
# Keyframes parameters. Only keyframes points are added to the maps.
keyframes_group = slam_group.add_group("Keyframes", type="collapse")
keyframes_group.add("keyf__distance_threshold", double_t, 4,
                    "[m] Min distance to travel since last KF to add a new one",
                    0.5, 0.1, 2.)
keyframes_group.add("keyf__angle_threshold", double_t, 4,
                    "[°] Min angle to rotate since last KF to add a new one",
                    5., 0., 180.)
# WARNING : these parameters are linked to the confidence threshold parameter
# If they are reduced, the confidence threshold may need to be increased to not take too many moving objects

# -------------------------------------------------------------------------------------------------
# Confidence estimators on pose output
confidence_group = slam_group.add_group("Confidence", type="collapse",)
overlap_group = confidence_group.add_group("Overlap", type="tab")
# 1 uses all points, 0.5 uses 1 point over 2, etc., 0 disables overlap computation.
overlap_group.add("overl__sampling_ratio", double_t, 5,
                  "# [0-1] Ratio of points to compute overlap on to save some time.",
                  0.5, 0., 1.)
motion_limits_group = confidence_group.add_group("Motion Limits", type="tab")
motion_limits_group.add("ml__acceleration_min", double_t, 5,
                        "[linear_acc (m/s2), angular_acc (°/s2)] Acceleration minimum.",
                        -16331239353195370)
motion_limits_group.add("ml__acceleration_max", double_t, 5,
                        "[linear_acc (m/s2), angular_acc (°/s2)] Acceleration maximum.",
                        16331239353195370)
motion_limits_group.add("ml__velocity_min", double_t, 5,
                        "[linear_vel (m/s2), angular_vel (°/s2)] Velocity minimum.",
                        -16331239353195370)
motion_limits_group.add("ml__velocity_max", double_t, 5,
                        "[linear_vel (m/s2), angular_vel (°/s2)] Velocity maximum.",
                        16331239353195370)
# 0 disables motion limits check.
# WARNING : the logging time out must be set greater than this value.
motion_limits_group.add("ml__time_window_duration", double_t, 5,
                         "[s] Duration on which to compute the local velocity/acceleration.",
                         0., 0.)

# -------------------------------------------------------------------------------------------------
# Keypoints maps, saved as downsampled voxel grids
voxel_grid_group = slam_group.add_group("Voxel Grid", type="collapse")

voxel_grid_general_group = voxel_grid_group.add_group("Voxel Grid General Parameters", type="tab")
    # How to update the maps:
    #  0) No update is performed. Initial maps are kept as they are.
    #     WARNING: Do not set this parameter to 0 if no initial maps have been loaded!
    #  1) New keypoints are added if they lie in a free voxel relatively to an initial map
    #  2) All new keypoints are added and the map is updated (initial keypoints can disappear)
    #     1) and 2) will be equivalent if no initial maps have been loaded.
    # This is equivalent to publishing :
    #          *SlamCommand::DISABLE_SLAM_MAP_UPDATE
    #          *SlamCommand::ENABLE_SLAM_MAP_EXPANSION
    #          *SlamCommand::ENABLE_SLAM_MAP_UPDATE
    # to 'slam_command' topic at startup.
voxel_grid_general_group.add("vg__update_maps", int_t, 6,
                      "Mode to update the maps (more info in LidarSlam.cfg)",
                      2, 0, 2)

leaf_size_group = voxel_grid_group.add_group("Leaf Size", type="tab")
leaf_size_group.add("ls__edges", double_t, 6,
                    "[m] Resolution used to downsample the edges map with a VoxelGrid filter.",
                    0.30, 0., 2.)
leaf_size_group.add("ls__intensity_edges", double_t, 6,
                    "[m] Resolution used to downsample the intensity edges map with a VoxelGrid filter.",
                    0.20, 0., 2.)
leaf_size_group.add("ls__planes", double_t, 6,
                    "[m] Resolution used to downsample the planes map with a VoxelGrid filter.",
                    0.60, 0., 2.)
leaf_size_group.add("ls__blobs", double_t, 6,
                    "[m] Resolution used to downsample the blobs map with a VoxelGrid filter.",
                    0.30, 0., 2.)

# WARNING: the leaf sizes are linked with the confidence threshold parameter
# if they are reduced the confidence threshold may need to by reduced as well to extract enough target keypoints
voxel_grid_general_group.add("vg__size", int_t, 6,
                     "[voxels] Size of the voxel grid used to store keypoints maps : n*n*n voxels.",
                     50, 10, 100)
voxel_grid_general_group.add("vg__resolution", double_t, 6,
                     "[m/voxel] Resolution of a voxel.",
                     10, 1., 20.)

# The sampling modes allow to decide which point to keep when downsampling the map using a voxel grid.
# 0) Keep the first point scanned in the voxel,
# 1) Get the last point scanned in the voxel,
# 2) Select the point with max intensity,
# 3) Select the closest point to the voxel center,
# 4) Compute the centroid of all points laying in the voxel.
sampling_mode = voxel_grid_group.add_group("Sampling mode", type="tab")

sampling_mode.add("sm__edge", int_t, 6,
                  "sample mode for edge (more info in LidarSlam.cfg)",
                  2, 0, 4)
sampling_mode.add("sm__intensity_edge", int_t, 6,
                  "sample mode for intensity edge (more info in LidarSlam.cfg)",
                  2, 0, 4)
sampling_mode.add("sm__plane", int_t, 6,
                  "sample mode for plane (more info in LidarSlam.cfg)",
                  2, 0, 4)
sampling_mode.add("sm__blob", int_t, 6,
                  "sample mode for blob (more info in LidarSlam.cfg)",
                  2, 0, 4)

voxel_grid_general_group.add("vg__decaying_treshold", double_t, 6,
                     "[s] Time duration after which to eliminate a not fixed keypoint from the map.",
                     -1, -1, 3600)
# Minimum number of frames that must have reached a map voxel
# to consider the voxel contains a target keypoint.
# It is used to reject moving objects from the map
# WARNING: this parameter may need to be adapted to the velocity of the robot,
# and the parameterization : see leaf_size keyframes parameters for more details
voxel_grid_general_group.add("vg__min_frames_per_voxel", int_t, 6,
                     "Minimum number of frames reaching a map voxel to consider the voxel contains a target keypoint. (more info in LidarSlam.cfg)",
                     2, 0, 10)

# -------------------------------------------------------------------------------------------------
#* HERE
# Keypoint extractor for each LiDAR sensor
ke_group = slam_group.add_group("Keypoint Extractor", type="collapse")

ke_general_group = ke_group.add_group("General Keypoint Extractor parameters", type="tab")

# Single LiDAR input
single_type_enable = ke_group.add_group("Type Enable", type="tab")
single_type_enable.add("st__edge", bool_t, 7,
                       "Are edge keypoint used",
                       True)
single_type_enable.add("st__intensity_edge", bool_t, 7,
                       "Are intensity edge keypoint used",
                       True)
single_type_enable.add("st__plane", bool_t, 7,
                       "Are plane keypoint used",
                       True)
single_type_enable.add("st__blob", bool_t, 7,
                       "Are st__blob keypoint used",
                       True)

ke_general_group.add("ke__max_points", int_t, 7,
             "Maximum number of keypoints of each type to extract",
             1000, 0, 10000)
ke_general_group.add("ke__voxel_grid_resolution", double_t, 7,
             "[m/voxel] Size of a voxel to downsample the extracted keypoints",
             2., 0.5, 5.)
ke_general_group.add("ke__input_sampling_ratio", double_t, 7,
             "Ratio of points from which to extract the keypoints (for computation time issues)",
             1., 0., 1.)
ke_general_group.add("ke__min_distance_to_sensor", double_t, 7,
             "[m] Minimal point to sensor distance to consider a point as valid.",
             1.5, 0.5, 5.)
ke_general_group.add("ke__min_azimuth", double_t, 7,
             "[°] Minimal azimuth angle to consider the point as keypoint. Right thumb rule between min/max azimuth angles.",
             0., 0., 360.)
ke_general_group.add("ke__max_azimuth", double_t, 7,
             "[°] Maximal azimuth angle to consider the point as keypoint. Right thumb rule between min/max azimuth angles.",
             360., 0., 360.)
ke_general_group.add("ke__min_beam_surface_angle", double_t, 7,
             "[°] Minimal angle between the point surface and the laser beam to consider a point as valid.",
             10., 0., 360.)
ke_general_group.add("ke__neighbors_side_nb", int_t, 7,
             "[>1] Minimum number of neighbors used on each side to estimate curvature and detect edges and planes.",
             4, 1, 16)
ke_general_group.add("ke__neighbors_radius", double_t, 7,
             "[m] Minimum radius to define a neighborhood on each side of the studied point.",
             0.05, 0, 1.)
ke_general_group.add("ke__plane_sin_angle_threshold", double_t, 7,
             "[0-1] Sharpness threshold to select a planar keypoint (selected if sin angle is less than threshold).",
             0.5, 0, 1)
ke_general_group.add("ke__edge_sin_angle_threshold", double_t, 7,
             "[0-1] Sharpness threshold to select an edge keypoint (selected if sin angle is more than threshold).",
             0.86, 0, 1)
ke_general_group.add("ke__edge_depth_gap_threshold", double_t, 7,
             "[m] Threshold upon depth gap in neighborhood to select an edge keypoint.",
             1., 0., 10.)
ke_general_group.add("ke__edge_nb_gap_points", int_t, 7,
             "[points] Minimum number of successive missing points to consider a space gap.",
             10, 2, 100)
ke_general_group.add("ke__edge_intensity_gap_threshold", double_t, 7,
             "[0-255] Threshold upon intensity gap to select an edge keypoint.",
             50., 0., 255.)

# ke_general_group.add("ke__", , 7,
#              "",
#              , ,)

#* LOOK "HERE" in slam_config_outdoor to know which parameter continue
#TODO create level variable for level inside of cfg
#TODO add a global group in each group to have proper tabulation
#TODO if description is too long : add precision than their is more info in .cfg
#TODO define infinity macro ?
#TODO define enum when it is a var with mode (ex undistortion_mode)
#TODO erase every std::cout at the end
#TODO read again every parameters to be sure to not forget any from yaml to cfg and config to slam
#TODO discuss Julia about what is the best look for interface ?
#TODO discuss Julia about multi LIDAR functions and how to do it with dynamic configure
#TODO erase min,max,default in description (useless with native dynamic_reconfigure min, max)
#TODO add fct to convert string to array of double or int
#TODO do cfg file for aggregation_config parameters
#TODO update documentation
exit(gen.generate(PACKAGE, "lidar_slam", "LidarSlam"))